#!/usr/bin/env node
/**
 * Opinionated commit message validator
 * Mostly follows git recommendations and conventional commits but add a twist of emoji
 * https://git-scm.com/docs/git-commit
 * https://www.conventionalcommits.org/en/v1.0.0/
 * https://gitmoji.dev/
 * 
 * It validates:
 * - the summary is MAX_SUMMARY_LINE_SIZE (50) characters
 * - a prefix is present
 * - a description is present
 * 
 * It formats the commit:
 * - add the correct emoji defined in COMMIT_TYPE for the summary prefix
 * - group the footers together and insure a blank line between footer and body
 * - it breaks the body line size to MAX_BODY_LINE_SIZE (72)
 * 
 * Author: https://github.com/fredericrous/ 
 */
const fs = require('fs');
const [/*interpreter path*/,/*script name*/, filename] = process.argv;

const MAX_SUMMARY_LINE_SIZE = 50;
const MAX_BODY_LINE_SIZE = 72;
const COMMIT_TYPE = {
  feat: 'âœ¨',
  fix: 'ðŸ›',
  docs: 'ðŸ“šï¸',
  style: 'ðŸŽ¨',
  refactor: 'â™»ï¸',
  revert: 'âªï¸',
  perf: 'âš¡ï¸',
  test: 'ðŸš¨',
  chore: 'ðŸ”§',
  'chore-deps': 'ðŸ”—',
  build: 'ðŸ“¦ï¸',
  ci: 'ðŸ‘·',
  release: 'ðŸš€',
  security: 'ðŸ”’ï¸',
  i18n: 'ðŸŒ',
  breaking: 'ðŸ’¥',
  config: 'âš™ï¸',
  add: 'âž•',
  remove: 'âž–',
};
const COLORS = {
  green: '112',
  orange: '208',
  red: '160',
}

if (require.main === module) {
  if (!filename) {
    console.info([
      'Usage:',
      '',
      'node commit-msg {commit-message-file-name}'
    ])
    process.exit(1);
  }
} else {
  console.error('Place this script in your git hooks/ folder or call it from your shell.');
  process.exit(1);
}
const commitMsg = fs.readFileSync(filename, 'utf8');
const emojiArray = Object.values(COMMIT_TYPE);
const typeArray = Object.keys(COMMIT_TYPE);

const message = function formatMsg() {
  const mark = (process.platform === 'win32') ? {
    ok: '\u2713',
    err: '\u2717'
  } : {
    ok: 'âœ“',
    err: 'âœ—',
  };

  const colorMsg = (msg, color) => `\u001b[38;5;${color}m${msg}\u001b[0m`;
  return {
    valid: (msg) => console.info(`  ${colorMsg(mark.ok, COLORS.green)} ${msg}`),
    error: (msg) => console.error(`  ${colorMsg(mark.err, COLORS.red)} ${msg}`),
    orange: (msg) => colorMsg(msg, COLORS.orange),
  };
}();
const noComments = (lines) => lines?.replace(/^#.*(\n|$)/gm, '') || ''; // lines.filter((line) => !/^#.*\n/.test(line));
const validateSummarySize = (commitMsg, maxCharcaters) => {
  const [firstLine] = noComments(commitMsg).split('\n');
  return firstLine && firstLine.length < maxCharcaters;
};
if (!validateSummarySize(commitMsg, MAX_SUMMARY_LINE_SIZE)) {
  message.error(`Commit's first line should exist and be under ${message.orange(MAX_SUMMARY_LINE_SIZE)} characters.`);
  process.exit(1);
}
message.valid(`Summary size is inferior to ${message.orange(MAX_SUMMARY_LINE_SIZE)} characters`);

const extractConventionalCommit = (commitMsg, emojiArray, typeArray) => {
  function emojiValuesObjectToUnicodeArray(emojiValuesObject) {
    function emojiToUnicode(input) {
      if (input.length === 1) return input.charCodeAt(0);
      const comp = (input.charCodeAt(0) - 0xD800) * 0x400
        + (input.charCodeAt(1) - 0xDC00) + 0x10000;
      return comp < 0 ? input.charCodeAt(0) : comp;
    };
    return emojiValuesObject
      .map(emojiToUnicode)
      .map(x => '\\u' + x.toString(16));
  }
  const emojiRegex = emojiValuesObjectToUnicodeArray(emojiArray).join('|');
  const commitTypeRegex = typeArray.join('|');
  const vaildateCommitRegex = new RegExp(`^\\s{0,}(${emojiRegex})?\\s{0,}(${commitTypeRegex})(\\(\\w+\\))?(!)?:\\s{0,}(.*)`, 'ms');
  return commitMsg.match(vaildateCommitRegex) || [];
}
const [/*input*/,/*emoji*/, prefix, scope, breakingChanges, restOfMessage] = extractConventionalCommit(commitMsg, emojiArray, typeArray);
if (!prefix) {
  message.error(`Commits MUST be prefixed with a type, which consists of a noun:
  ${typeArray.map(message.orange).join(', ')}
  The prefix must be followed by the OPTIONAL scope, OPTIONAL !,
  and REQUIRED terminal colon and space.
  A scope MAY be provided after a type. A scope MUST consist of a noun describing
  a section of the codebase surrounded by parenthesis, e.g., fix(parser)`);
  process.exit(1);
}
message.valid(`A prefix is defined`);

const [description, ...commitBody] = noComments(restOfMessage)?.split('\n') || [];
if (!description) {
  message.error(`A description MUST immediately follow the ${message.orange('colon')} and ${message.orange('space')} after the type/scope prefix.
  The description is a short summary of the code changes, e.g., fix: array parsing issue when multiple spaces were contained in string.`);
  process.exit(1);
}
message.valid(`A description is present in the summary`);

//wrap might be shitty if there is a comment
const wrap = (w) => {
  const breakLineRegex = new RegExp(`(?![^\\n]{1,${w}}$)([^\\n]{1,${w}})\\s`, 'g');
  return (text) => text.replace(breakLineRegex, '$1\n');
};
const formatFooter = () => {
  const isFooter = (text) => /\w-\w{1,}:\s\w/.test(text) ||
    /BREAKING[ -]CHANGE:\s\w/.test(text) || /Refs:?\s#?\d/.test(text) || text === '';
  function truthyCounter([firstElem, ...rest], tester, counter = 0) {
    return tester(firstElem) ? truthyCounter(rest, tester, counter + 1) : counter;
  }
  const removeLastNewLines = (text) => text.replace(/\n{1,}$/, '');
  return (format) => {
    const commitMsgArray = removeLastNewLines(noComments(format)).split('\n');
    const invertedCommitMsg = commitMsgArray.slice().reverse();
    const footerSize = truthyCounter(invertedCommitMsg, isFooter);
    const bodyWithoutFooter = commitMsgArray.slice(0, commitMsgArray.length - footerSize);
    const footerWithoutExtraNewLines = commitMsgArray
      .slice(commitMsgArray.length - footerSize).filter(x => x !== '');
    return [
      ...bodyWithoutFooter,
      '',
      ...footerWithoutExtraNewLines
    ].join('\n');
  }
};
const format = `${COMMIT_TYPE[prefix]}  ${prefix}${scope || ''}${breakingChanges || ''}: ${description}\n\n${wrap(MAX_BODY_LINE_SIZE)(commitBody.join('\n'))}\n`;
fs.writeFileSync(filename, formatFooter()(format), 'utf8');
